# 执行环境及作用域
### 执行环境：
执行环境可分为全局执行环境和局部执行环境。每一个执行环境都有一个与之关联的变量对象，这个变量对象包含了这个执行环境的变量和函数。
### 执行环境流机制：
每个函数都有自己的执行环境，当执行流进入一个函数时，这时会把函数这个执行环境放到环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAscript程序中的执行流正是由这个方便的机制控制着。
### 作用域链：
当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端(也就是前面的意思)，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即**arguments对象(这个对象在全局环境中是不存在的)**。作用域链中的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
#### 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止(如果找不到标识符，通常会导致错误发生)。
  **请看下面的例子**
```js
  var color = "blue";
  function changeColor() {
    if(color === "blue") {
      color = "red";
    } else {
      color = "blue";
    }
  }
  changeColor();
  console.log("Color in now" + color); // Color in nowred
```

在这个简单的例子中，函数changeColor()的作用域链包含两个对象:它自己的变量对象(其中定义这arguments对象)和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域中找到它</br>

```js
var color = "blue";
  function changeColor() {
    var anotherColor = "red";

    function swapColors() {

      var tempColor = anotherColor;

      anotherColor = color;

      color = tempColor;
      // 这里可以访问color，anotherColor和tempColor
    }
    swapColors();
  // 这里可以访问color，anotherColor和tempColor
  }
  //这里只能访问color
  changeColor();
```
![]('/image/4.2执行环境图解.png')

在局部作用域中定义的变量可以在局部环境中与全部变量互换使用在上面一个例子中，共涉及到了3个执行环境：**全局环境，changeColor()的局部环境和swapColors()的局部环境**。全局环境中有一个变量**color**和一个函数changeColor()。</br>
**changeColor**的局部环境中有一个名为**anotherColor**的变量和一个名为**swapColors()**函数，但它也可以访问全局环境中的变量**color**。**swapColors()**的局部环境中有一个变量**tempColor**，该变量只能在这个环境中访问到。无论全局环境还是**changeColor()**的局部环境都无权访问**tempColor**。然而在**swapColors()**内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境

:::warning 注意
切记！内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量的函数。这些环境之间的联系是线性，有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名，但任何环境都不能通过向下搜索作用域链而进入另一个执行环境
:::
### 延长作用域链：
虽然执行环境的类型总共只有两种类型---全局和局部(函数)，但还是有其他方法来延长作用域链。这么说因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种想象。具体来说，就是当执行流进入下列任何语句时，作用域链就会得到加长：</br>
try-catch语句的catch块;  还有with语句。这两个语句都会在作用域的前端添加一变量对象。在with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象。其中包含的是被抛出的错误对象的声明

with语句接收的是一个location对象，因此其变量对象中就包含了location对象的所有属性和方法，而在这个变量对象被添加到了作用域链的前端。buildUrl()函数定义了一个变量qs。当在with语句中引用变量href时(实际引用的是location.href)，可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl中定义的那个变量而该变量位于函数环境的变量对象中。至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回
```js
function buildUrl() {
  var qs = "?debug=true";
  with(location){
    var url = href + qs;
  }
    return url;
}
console.log(buildUrl())
```